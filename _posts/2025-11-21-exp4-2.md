---
layout: default
title: 打印N阶网格实心菱形
---

# 算法初探 打印N阶实心菱形

{% capture content0 %}

最近在学校的实验课上看到了这个题目，题目并不难，解法也很简单，但是我观察了我周边的同学的解法，意识到大部分人并没有掌握计算思维，可以说对于计算机程序的理解还有不足。

笔者恰好略有经验，便决定借助这道题，简单的解释一下解一道算法题的方法，并给出方法论。

但是还请各位务必记住，方法论的形成是基于大量的经验的积累，基于少量的经验而形成的方法论是能验证其准确性以及适用性的，所以这篇文章还希望各位批判性的去看，笔者也算是抛砖引玉，希望可以有更加好的想法和思路被提出。

{% endcapture %}

{% include details.html summary="点击查看这个本文的初衷" content=content0 %}

# 题目描述

输入一个奇数 $n$，输出一个由构成的 $n$ 阶实心菱形。

输入格式：一个奇数 $n$；

输出格式：输出一个由`*`构成的 $n$ 阶实心菱形。具体格式参照输出样例。

数据范围：$1 < n \le 99$

输入样例:

$5$

输出样例:
```text
  *
 ***
*****
 ***
  *
```
# 解题思路

## 初步分析

首先这个图形必然是使用循环来实现的，所以我们可以尝试使用两个`for`循环来绘制一个完整的方形。

例如:
```text
*****
*****
*****
*****
*****
```
乐观的看，我们已经成功了一半，也就是菱形的`*`已经成功绘制。

问题就在于，我们如何把4个角的`*`变成`<Space>`呢?

我们不妨把这个菱形(方形)的中间作为坐标原点，以右和上分别作为$x$和$y$轴正方向，建立平面直角坐标系，以便于描述这个问题。第一和第四象限的6个`*`号很好理解，我们可以直接不输出。那么在第二和第三象限的`*`呢?

## 第一种解法

其实观察我们需要绘制的图形，我们可以看到一个很有用的规律，那就是中间的一行全是`*`，这就给了我们启发。

我们可以分两次绘制。第一次绘制上面，第二次绘制下面。这样就把画一个菱形的问题转化为了画两个三角形的问题，上面的比下面的大一行。当然了，我们也可以变成画两个相同的三角形，外加一个直线的方式。以上的模式并没有区别。

这里的结构就是

```cpp
for(condition)
    // 绘制上三角形
for(condition)
    // 绘制下三角形
```

这里就是一个很朴素的解法，仅仅只需要两个循环就可以解决问题，所以我们不进一步解释了。

实际上，我们可以有更好的解法，就是利用坐标分析的方法。

## 第二种解法

我们可以以这样一个正方形的左上角为零点，构建一个坐标系，随后做一个`if-else`判断即可。

> 值得注意的是，在本文中，所有的数列均默认由1开始。

也就是
```cpp
for(condition)
    if() // 在菱形中
        printf("*");
    else
        printf(" ");
```

现在的问题就是找到在菱形中的点的分布的特征，当然反之亦可。

我们知道什么呢?我们知道的是这个正方形的边长 $n$ (奇数)。

我们把这个图形抽象出来，这个菱形其实是使用了两个不同的字符，只不过一个是`<Space>`而已。所以我们可以把每一行也变成一个循环，先循环输出字符1，然后输出字符2。

那么现在的关键就是获取到这两个字符的个数。

不妨另`*`的个数为 $x$，`<Space>`个数为 $y$。这个坐标系的 $y$ 轴为`i`，$x$ 轴为`j`(这是由`for`循环的默认参数决定的，其实可以随意更改)。$n$ 的中点为 $m$。显然$m=\frac{n-1}{2}$。

其实这个也好处理，第一行的`*`是1个，第二行是3个，所以这就是一个简单的奇数数列。所以获得到`x=i*2-1`。但是我们显然可以注意到，在后面的个数是反过来的，是在减少的。

所以我们需要分情况讨论。如果是上部分，那么就不需要改变，但是如果是下部分，那么就需要我们去改变这个方程。

换句话说如下，其中，$f(x)$指的是上半部分的`*`个数，$g(x)$是下半部分的个数。

1. $已知f(1)=1，f(2)=3，求f(x)方程$。
2. $已知g(n)=1，g(n-1)=3，求g(x)方程$。

$f(x)=2x-1$是我们找到的一个符合题意的方程，现在我们需要找到符合题意的$g(x)$。

我们可以从$f(x)$出发，也就是$g(n)=f(1)=1$，换句话来说，我们需要找到一个$h(x)$，使得$h(n)=1，h(n-1)=2$。

这样一个显然的反比例关系，我们可以显然的想出来，这是一个斜率为$-1$的一次函数。

那么这个方程显然可解，也就是$y=-(x-n)+1$。化简得到$h(x)=n+1-x$。联立$g(n)=f(1)=1$和$f(x)=2x-1$得到$g(x)=2n-2x-1$。

至此，我们解决了`*`的个数，那么`<Space>`的个数就显而易见了，一行总共`n`个字符，图形对称，那么显然易见，`<space>`的个数是$\frac{n-f(x)}{2}$(以上半部分为例)。

那么我们就可以写出这个算法了。

```cpp
int m = (n - 1) / 2;
for (int i = 1; i <= n; i++)
{
    if (i <= m)
    {
        x = 2 * i - 1;
    }
    else
    {
        x = 2 * n - 2 * i + 1;
    }
    y = (n - x) / 2;
    for (int j = 0; j < y; j++)
        printf(" ");
    for (int j = 0; j < x; j++)
        printf("*");
    printf("\n");
}
```
现在我们可以完整的写出这个程序了。如下
```cpp
#include <stdio.h>

int main()
{
    int x, y, n;
    scanf("%d", &n);
    int m = (n + 1) / 2;
    for (int i = 1; i <= n; i++)
    {
        if (i <= m)
        {
            x = 2 * i - 1;
        }
        else
        {
            x = 2 * n - 2 * i + 1;
        }
        y = (n - x) / 2;
        for (int j = 0; j < y; j++)
            printf(" ");
        for (int j = 0; j < x; j++)
            printf("*");
        printf("\n");
    }
}
```

值得注意的是，这里有一个有趣的地方。如果你把`int m = (n + 1) / 2;`中的加号改成减号，那么结果是不变的。想想为什么?

{% capture content1 %}

首先我们为我们的正确算法命名为原算法，即$m_1=\frac{n+1}{2}$。

那么修改后的算法为改算法，即$m_2=\frac{n-1}{2}$。

我们不妨令$n=2*k+1,k \in N$。

此时，原算法有
- $i=k,f_1(k)=2k-1$
- $i=k+1,f_2(k+1)=2(2k+1-k-1)+1=2k+1$

而此时有改算法得

- $i=k+1,f_1(k+1)=2k+1$
- $i=k+2,f_2(k+1)=2(2k+1-(k+2))+1=2k-1$

这个部分的计算或许会让我们摸不着头脑，不知道为什么需要这么计算。

实际上这部分是基于一个简单的思考**当我们更改了m的计算方式，什么发生了改变?**如果我们知道了什么发生了改变，那么我们显然就知道了为什么会导致我们的结果不会发生改变了。

好的，那我们来回答这个问题，什么发生了改变?

答案显而易见，在上面的代码中，发生改变的毫无疑问是函数$f_1(x)$和$f_2(x)$的覆盖范围。因为`m`的取值决定了`if`语句的分支，进而决定了使用的函数。

那么我们只需要知道，这个部分的函数值是什么就行了。

如果使用原算法，那么`if`语句中的临界值就是`k`(使用$f_1(x)$)和`k+1`(使用$f_2(x)$)。

同理，我们知道使用改算法的时候的临界值`k+1`和`k+2`。

所以在原算法中，$f_1(x)$的覆盖范围是$[1,k]$，$f_2(x)$的覆盖范围是$[k+1,2k+1]$。

在改算法中，$f_1(x)$的覆盖范围是$[1,k+1]$，$f_2(x)$的覆盖范围是$[k+2,2k+1]$。

即是说，在两个算法中，发生改变的值是`k+1`这一个点。这个点在原算法中，使用的函数是$f_2(x)$，在改算法中，使用的是$f_1(x)$。

而我们又由上面的计算知道，$f_2(k+1)=f_1(k+1)$。

这部分的分析可以使用如下的数轴显然的看到。

<!-- ![funaction](/src/fun_range.png#pic_center =600x600) -->
<div align="center">
<img src="/src/fun_range.png" width="600"/>
</div>

所以结果不变是数学结构决定的，也就是一个美丽的巧合。

> 或许有更加深层次的原理，但是笔者决定不深究他。
> 以及以上的讨论都默认定义域是整数的子集。

{% endcapture %}

{% include details.html summary="原因解释" content=content1 %}

**总结**

我们现在来总结一下这个解法的思路。

这个算法的核心思路是计算`*`和`<Space>`的个数，所以我们需要构建起个数与某一个量的关系，这个量毫无疑问使用起行数是最好的。即是说，我们需要使用行数来表示`*`和`<Space>`的个数。我们不妨使用数学中的坐标系，即是说从1开始。

所以我们有了一个方程组。

$$f(1)=1\\f(2)=3\\......\\f(\frac{n+1}{2})=n$$

(最后一个方程是显而易见的，由于中间的一行全是`*`，没有空格，自然是`n`了)

我们需要找到一个函数$f(x)$符合他。我们很容易找到函数$f(x)=2*n-1$是符合的。

随后我们在讨论这个函数的时候，发现这个函数并不一直是对的，从图形上也能看出来，后续的个数并不是单调递增的。所以$f(x)$是一个分段函数。

那我们需要找出他的后面的解析式。这个部分的流程与以上的流程如出一辙，我们也发现了一组方程。

$$g(n)=1\\g(n-1)=3\\......\\g(\frac{n+1}{2})=n$$

我们可以发现，形式其实很像，不如说具有相同的对应关系，这也符合几何图形。

也就是如下的方程组

$$f(1)=g(n)=1\\f(2)=g(n-1)=3\\......\\f(\frac{n+1}{2})=g(\frac{n+1}{2})=n$$

那么就是我们需要找到一个函数$h(x)$，使得$h(n)=1,...,h(\frac{n+1}{2})=\frac{n+1}{2}$。

这很好找，我们找到了$h(x)=n+1-x$，把他和$f(x)$联立一下，就有了$g(x)$的解析式。
也就是$g(x)=f(h(x))$。进而得到了$g(x)$的解析式，得到了完整的分段函数$f(x)$。

$$
f(x)= \begin{cases}
2x-1, & x\in [1,\frac{n+1}{2}] \\
2(n-x)+1 & x\in [\frac{n+1}{2},n]
\end{cases}
$$

这里也更加明显了，这个函数是一个连续的函数，分段的点是重合的。

得到了$f(x)$之后，由于边长是一个常量$n$，所以显然`<Space>`的个数也是可以表示为`*`个数之间的函数。

即$I(x)=\frac{n-f(x)}{2}$

随后算法的实现就显而易见了。

> 实际上还有更多的解法，但是这里就不讨论其他的解法了。

# 算法改进

上面的算法二显然不是最优的，我们可以改进他。

### 从过程中改进

我们知道，函数具有三要素，自变量(定义域)，因变量(值域)，对应法则。

在上面的总结部分，我们讨论到了我们使用的是修改这个**对应法则**的方法来实现个数的对应，那我们自然可以换一个角度，通过修改**自变量**来实现获取到目的**因变量**的目的，如下图。

{% raw %}

<div class="mermaid">
graph LR
A["x1"]
B["x2"]
C["Y"]
A--"f1(x)"-->C
B--"f2(x)"-->C
B--"F(x)"-->A
</div>

{% endraw%}

> 这部分有点图论的味道了有没有?

也就是我们可以通过把$x_2$映射到$x_1$来实现$x_2$间接映射到$Y$。我们也可以说，我们使用了一个复合函数来实现这一个目的。

接下来我们来找这个复合函数。我们同样以$n=5$为例，已知如下。

$$
F(n)=1\\
F(n-1)=2\\
F(n-3)=3\\
...\\
F(n)=n
$$

我们显然可以得到解析式$F(x)=n-x+1$。那么我们就有了另一个解决的方案，我们不再使用`if-else`来更改决定`*`个数的函数，而是使用统一的函数，我们来更改自变量。

所以我们有了如下的方程组。

$$
F(x)=n-x+1\\
f(x)=2x-1\\
g(x)=\frac{n-f(x)}{2}
$$

我们可以有如下的代码。

```cpp
#include <stdio.h>

int main()
{
    int n;
    scanf("%d", &n);
    int m = (n - 1) / 2;
    for (int i = 1; i <= n; i++)
    {
        int l = (i <= m) ? i : n - i + 1;
        int x = 2 * l - 1;
        int y = (n - x) / 2;
        for (int j = 0; j < y; j++)
            printf(" ");
        for (int j = 0; j < x; j++)
            printf("*");
        printf("\n");
    }
    return 0;
}
```

### 从结果中改进

对于算法的改进，不仅仅局限于对于算法过程的改进，再有了一个完整的算法之后，我们也可以根据这个算法来改善算法，也可以说是找到一个新的算法去处理这个问题。让我们再次观察这个输出的结果

```text
  *
 ***
*****
 ***
  *
```

我们注意到，这个图形一定是对称的，这一点在我们上面的方程中也多次体现。那么是不是说，如果我们处理好了这个图形的四分之一，也就可以处理好这个图形呢?

我们观察到，如果以中心点为基点的话，我们可以看到`*`和`<Space>`的个数和是**不变**的。也就是说，这就又是一个函数关系，甚至更加简单。

也就是`(n-1)/2-i`为空格数，而`*`的个数也可以使用`2*l-1`来简单的确定我们只需要更改`l`的判定即可。

最后我们得到了如下的代码。

```cpp
#include <stdio.h>

int main()
{
    int n;
    scanf("%d", &n);
    int m = (n + 1) / 2;

    for (int i = 1; i <= n; i++)
    {
        int l;
        if (i <= m)
        {
            l = i;
        }
        else
        {
            l = n - i + 1;
        }
        int y = m - l;
        int x = 2 * l - 1;

        for (int j = 0; j < y; j++)
            printf(" ");
        for (int j = 0; j < x; j++)
            printf("*");
        printf("\n");
    }

    return 0;
}
```

# 代码改进

我们将以我们上面的代码为例进行改进。

## 功能改进

我们的代码中没有添加对用户的输入的检验，我们都默认了输入的合法性，这里我们把他们加上。

### 处理非法数字

首先我们判断输入是不是一个奇数，是不是介于1和99之间。

```cpp
#include <stdio.h>

int main()
{
    int n;
    scanf("%d", &n);
    while (n % 2 == 0 || n < 1 || n > 99)
    {
        printf("Error Input! Please Input again!\nInput:");
        scanf("%d", &n);
    }
    int m = (n + 1) / 2;
    for (int i = 1; i <= n; i++)
    {
        int l;
        if (i <= m)
        {
            l = i;
        }
        else
        {
            l = n - i + 1;
        }
        int y = m - l;
        int x = 2 * l - 1;

        for (int j = 0; j < y; j++)
            printf(" ");
        for (int j = 0; j < x; j++)
            printf("*");
        printf("\n");
    }
    return 0;
}
```

这个改进已经可以处理对于非法的数字，但是如果是非法的字符，我们就无法处理。

所以我们现在来处理非法的字符。

### 处理非法字符

首先我们需要知道对于`scanf()`函数的输入流截断情况，通常来说有以下三种。

- 非法字符
- `<Space>`或者`<Tab>`或`<Enter>`键
- 达到对应的域宽

而对于非法的字符，我们的函数并不会读取这个字符，他会一直保持在流中，所以如果不读取这个字符的话，单单使用循环读取就会死循环，一直无法读取用户的输入。

所以遇到非法字符，我们通常需要使用`getchar()`把他读取出来。

这是一个简单的清空的案例`while ((ch = getchar()) != '\n' && ch != EOF);`，我们判断这个流中的字符是不是换行符以及是否是`EOF(Ending Of File)`。这里稍微提一下，`EOF`被定义在`stdio.h`中，其值为`-1`。

然后我们使用`scanf()`的返回值来判断是否成功的获取到了输入。

{% capture content2 %}

`scanf()`的定义是`int scanf(const char *__restrict__ _Format, ...)`

返回值返回的一般是成功获取的字符数量，举例而言`scanf("%d",&a)`，如果输入的是`6`，那么他就被成功的获取到，返回的是`1`，如果是错误的输入例如`a`，那么由于`a`没有被赋值，所以返回的就是`0`。

{% endcapture %}

{% include details.html summary="Scanf()函数返回值解释" content=content2 %}

较常见的处理方式是`int result = scanf("%d",&n);`来获取返回值，随后在循环结构中的分支语句中判断他。

综合以上，我们得出如下的结果。

```cpp
#include <stdio.h>

int main()
{
    int n;
    int result = scanf("%d", &n);
    char chr;
    while (result == 0 || n % 2 == 0 || n < 1 || n > 99)
    {
        while ((chr = getchar()) != '\n' && chr != EOF)
            ;
        printf("Error Input! Please Input again!\nInput:");
        result = scanf("%d", &n);
    }
    int m = (n + 1) / 2;
    for (int i = 1; i <= n; i++)
    {
        int l;
        if (i <= m)
        {
            l = i;
        }
        else
        {
            l = n - i + 1;
        }
        int y = m - l;
        int x = 2 * l - 1;

        for (int j = 0; j < y; j++)
            printf(" ");
        for (int j = 0; j < x; j++)
            printf("*");
        printf("\n");
    }
    return 0;
}
```

这个代码已经可以正常的运行。

> 处理非法字符的方式有很多种，文末会附上其他的几种方式。

## 形式改进

首先是修改变量名为有意义的名称。结果如下。为了保证可读性，我们把涉及算法的变量全部取了有意义的名字，而对于清空输入流的变量`chr`我就没有处理他，毕竟他的作用仅限于此行，且十分明显。

对于变量命名并非一定是改进这一环节的工作，同样可以在算法实现的初期就完成这一个工作。

```cpp
#include <stdio.h>

int main()
{
    int n;
    int result = scanf("%d", &n);
    char chr;
    while (result == 0 || n % 2 == 0 || n < 1 || n > 99)
    {
        while ((chr = getchar()) != '\n' && chr != EOF)
            ;
        printf("Error Input! Please Input again!\nInput:");
        result = scanf("%d", &n);
    }
    int mid = (n + 1) / 2;
    for (int i = 1; i <= n; i++)
    {
        int line;
        if (i <= mid)
        {
            line = i;
        }
        else
        {
            line = n - i + 1;
        }
        int spaces = mid - line;
        int stars = 2 * line - 1;

        for (int j = 0; j < spaces; j++)
            printf(" ");
        for (int j = 0; j < stars; j++)
            printf("*");
        printf("\n");
    }
    return 0;
}
```
这样的代码可读性就上升了很多。接下来我们对代码的结构做一个改进。

对于上面的处理非法输入的部分，我们观察到有两个`scanf()`语句，并且目的是一样的，所以我们可以把他们简化一下。
或许有人会想到使用`do-while()`循环来处理这个部分，但是由于初次的输出和错误的输出不同，所以不能使用`do-while()`循环来处理他。
(当然在循环中添加一个标志变量，使用`if-else`语句输出不同的提示信息也可以达到效果，但是与我们简化的目的相违背)，

一个简单的想法是改变我们的处理流程。一开始的流程是`如果有不符合条件的输入，就继续执行循环`，我们不妨改成`如果有符合的输入，就跳出循环`。

> 这个部分化简代码有没有化简门电路的味道?

所以我们最后可以得到类似如下的代码。

```cpp

#include <stdio.h>

int main()
{
    int n;
    char ch;
    while (1)
    {
        printf("Input: ");
        int result = scanf("%d", &n);
        while ((ch = getchar()) != '\n' && ch != EOF)
            ;
        if (result == 1 && n % 2 != 0 && n >= 1 && n <= 99)
            break;
        else
            printf("Error Input! Please Input an odd number between 1 and 99!\n");
    }
    int mid = (n + 1) / 2;
    for (int i = 1; i <= n; i++)
    {
        int line = (i <= mid) ? i : n - i + 1;
        int spaces = mid - line;
        int stars = 2 * line - 1;

        for (int j = 0; j < spaces; j++)
            printf(" ");
        for (int j = 0; j < stars; j++)
            printf("*");
        printf("\n");
    }
    return 0;
}
```
这个代码就是最终的成果。

# 总结

总结一下，我们借助这道简单的题目，详细的讨论了如何解决一个问题，优化一个算法，并给出了优化算法的方法论 (即要素分析)。

所以所谓做算法，即是如下的流程。

{% raw %}
<div class="mermaid">
graph LR
A[数学建模]-->B[构建算法]-->C[解决问题]-->D[优化解法]-->E[得到答案]
D--从结果优化-->A
D--从过程优化-->B
D--代码改进-->C
</div>
{% endraw %}

值得注意的是，从在数学建模的阶段进行良好的建模往往可以优化我们的算法，降低我们的优化成本。

# 附录

## 更好的处理非法输入的方法

```cpp
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int main()
{
    int n;
    char input[100];
    
    while (1)
    {
        printf("Input: ");
        if (fgets(input, sizeof(input), stdin) == NULL)
        {
            printf("Input error!\n");
            continue;
        }
        
        // 移除换行符
        input[strcspn(input, "\n")] = 0;
        
        // 检查输入是否为纯数字
        int valid = 1;
        for (int i = 0; input[i] != '\0'; i++)
        {
            if (!isdigit(input[i]))
            {
                valid = 0;
                break;
            }
        }
        
        if (valid && sscanf(input, "%d", &n) == 1 && n % 2 != 0 && n >= 1 && n <= 99)
        {
            break; 
        }
        else
        {
            printf("Error Input! Please Input an odd number between 1 and 99!\n");
        }
    }
    
    int mid = (n + 1) / 2;
    for (int i = 1; i <= n; i++)
    {
        int line = (i <= mid) ? i : n - i + 1;
        int spaces = mid - line;
        int stars = 2 * line - 1;

        for (int j = 0; j < spaces; j++)
            printf(" ");
        for (int j = 0; j < stars; j++)
            printf("*");
        printf("\n");
    }
    return 0;
}
```
这个代码使用`fgets()`函数和`sscanf()`函数来处理输入值，效果更好，可以处理形如`5a`这样的非法输入，原代码处理`5a`会当作5处理，然后`a`留在输入流中不被处理，尽管无后续操作，在程序结束的时候会被处理，没有实际影响，但是这个处理方式显然更加周到以及安全。

## 更简洁的渲染算法

```cpp
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <ctype.h>

int main()
{
    int n;
    char input[100];

    while (1)
    {
        printf("Input: ");
        if (fgets(input, sizeof(input), stdin) == NULL)
        {
            printf("Input error!\n");
            continue;
        }

        input[strcspn(input, "\n")] = 0;

        int valid = 1;
        for (int i = 0; input[i] != '\0'; i++)
        {
            if (!isdigit(input[i]))
            {
                valid = 0;
                break;
            }
        }

        if (valid && sscanf(input, "%d", &n) == 1 && n % 2 != 0 && n >= 1 && n <= 99)
        {
            break; 
        }
        else
        {
            printf("Error Input! Please Input an odd number between 1 and 99!\n");
        }
    }
    int center = (n + 1) / 2;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            int dx = abs(j - center);
            int dy = abs(i - center);

            if (dx + dy <= center - 1)
            {
                printf("*");
            }
            else
            {
                printf(" ");
            }
        }
        printf("\n");
    }
    return 0;
}
```
这个算法使用了**曼哈顿距离**的来渲染这个菱形。曼哈顿距离指的是在网格中水平和竖直的距离之和，可以简易的表示为 $d=|x_1-x_2|+|y_1-y_2|$。

网格菱形的定义就是在曼哈顿距离上横纵坐标之和为定值的图形，所以这里的算法显而易见了。